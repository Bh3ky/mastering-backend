# HTTP Caching and CORS

- when a client (browser, curl, mobile app) makes a request

```code
Client â†’ Server
```

- the server returns

```code
Status line
Headers
Body
```

- for example:
```code
HTTP/1.1 200 OK
Cache-Control: public, max-age=60
Content-Type: application/json

{"message": "hello"}

```

- as professional backend engineers we have to think primarily about:
    - status codes
    - headers
    - protocol behavior


## HTTP Caching


- suppose we get 10,000 users request to:

```code
GET /news
```

- without caching such a request would cause the server CPU to spike, latency increases which also directly cause an increase in costs. 


QUE: what is caching?

- caching basically means reusing a previous response instead of generating a new one. 
- HTTP supports caching at multiple layers
    - browser cache
    - CDN (cloudflare, fastly)
    - reverse proxy (NGINX)
    - client memory

- we control caching using HTTP headers


### 1. Cache-Control

- cache-control is a response header that tells the client:
    - whether the response can be cached
    - duration

```code
Cache-Control: public, max-age=60
```

- `public` that is any cache may store it
- `max-age-60` the response if fresh for 60 seconds. fresh means client will not even contact server again.

- helps reduce server load, latency, and network traffic


**How to Add Cache-Control Header in FastAPI**

- FastAPI allowa us to modify headers by injecting a Response object into the route function (known as dependency injection).

- Note: FastAPI injects it automatically if we declare it as a parameter


### 2. ETag (Stronger Caching)

- ETag = Entity Tag which is a string representing a specific version of a resource

```code
ETag: "abc123"
```

- Note: if the resourc changes, the ETag must change (usually generated by hashing the response body).

QUE: why hash??

- because if content changes even slightly, hash changes. gives us a fingerprint. 


Conditional Requests

- after first request, client stores the ETag. on the second request, client sends:
`If-None-Match: "abc123"`
- server logic:
    - if current ETag == client ETag -> return 304 Not Modified
    - Else -> return 200 with new body

- 304 Not Modified means:
    - resource has not changes
    - do NOT send body
    - client should reuse cached copy

- this helps save bandwidth and CPU.


**How to Generate ETag**

- conceptually,
    -  we convert response data to string
    - hash using hashlib.sha256
    - set header: ETag

- ETags are usually quoted as `ETag: "hashvalue"`


**Conditional Logic

- we must access request headers, compare `If-None-Match`, and if equal -> return 304 with empty body (client already has the body).


### CORS (Browser Security)

- CORS = cross-origin resource sharing
    - refers to the situations when a frontend running in a browser has JavaScript code that communicates with a backend, and the backend is in a different "origin" than the frontend.

- an origin consists of scheme (http/https), host, and port

"*" means allow any website to call this API which is dangerous especially when we use cookies, authentication, and handle private data.


**What problem does ETag solve??

- cache-control handles freshness duration while ETag handles version validation. 
- without ETag, client either uses cache blindly or fully re-downloads resource
- with ETag, we get conditional request. 

Flow Diagram

- first request:
    - client -> server
    - server responds

    ```code
    200 OK
    ETag: "abc123"
    Body: {...}
    ```

    - client stores both body and ETag

- second request:
    - client sends
    ```code
    If-None-Match: "abc123"
    ```

    - server compares:
        - if same -> 304 Not Modified
        - if different -> 200 OK with new body

- this helps save bandwidth, reduce latency, and reduce CPU usage. 


- ETag must be be deterministic. if the response body changes randomly (e.g., includes timestamp), the hash changes every time, thus we use stable content.
- how to generate a hash??
    - we convert response dict to string, then encode to bytes. we hash using sha256 then wrap in quotes.

full code example:

```python
from fastapi import FastAPI, Response
import hashlib
import json

app = FastAPI()

@app.get("/resource")
def get_resource(response: Response) -> dict[str, str]:
    data = {"message": "This is a cacheable resource."}

    # convert to consistent JSON string
    body = json.dumps(data, sort_keys=True)

    # generate hash
    etag = hashlib.sha256(body.encode()).hexdigest()

    # set headers
    response.headers["Cache-Control"] = "public, max-age=60"
    response.headers["ETag"] = f'"{etag}"'

    return data
```

- we use `sort_keys=True` because dictionary key order can change.
- if key order changes: 
    - hash changes, ETag changes, & cache breaks.


## CORS (Browser Security)

- browser security is very critical because:
    - backend APIs rarely live alone
    - they are almost always called by browsers
    - browswers enforce security rules that curl doesn't

**What is an origin??**

- an origin is defined by:
```code
Schema + Host + Port
```

example: `http://localhost:3000`
- Note: if any of these differe, it is a different origin. 

- Note: CORS is enforced by the browser, not the server. the server simply declares permissions


**Why CORS exists??**

- without CORS:
    - any malicious website can send authenticated requests using our cookies
    - read sensitive data
    - perform actions on behalf of users
- CORS  prevent arbitrary cross-origin reading of responses.


**How CORS works??**

- when a browser makes a cross-origin request:
    1. it adds an `Origin` header:
    ```code
    Origin: http://localhost:3000
    ```

    2. aerver must respond with:
    ```code
    Access-Control-Allow-Origin: http://localhost:3000
    ```
    - if not -> browser blocks response. 
    - Note: the request may still reach the server, but browser refuses to give the response to JS.


**Two Types of CORS**

1. Simple Requests
    - GET
    - no custom headers
    - no complex content types
- browser sends request directly

2. Preflight Requests
- if request is complext:
    - custom headers
    - PUT / DELETE
    - JSON content-type

- browser first sends:
```code
OPTIONS /resource
```

- server must respond with:
```code
Access-Control-Allow-Methods
Access-Control-Allow-Headers
```

- then browser sends real request


- FastAPI provides middleware to handle all of this automatically. 


```python
from fastapi.middleware.cors import CORSMiddleware

origins = [
    "http://localhost:3000",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

- allow_origins explicitly whitelists allowed frontend domains
- allow_credentials=True allow cookies and authorization headers
- allow_headers=["*"] allow custom headers


- Note: CORS doesn't prevent:
    - curl requests
    - postman requesrs
    - server-to-server requests

- it only affects browsers because it is a browser security model. 


## Rate Limiting (Basic)

- without rate limiting:
    - a single client can spam requests
    - this would cause the server CPU to spike
    - memory increases
    - negatively affects other users

- rate limiting means limiting how many requests a client can make within a certain time window. for example 5 request per 60 seconds per IP.
- if exceeded: `429 Too Many Requests`

- for now we just implement:
    - in-memory storage
    - per-IP tracking
    - fixed time window

**HOW??**

1. first we identify the client using:

```code
request.client.host
```
- this gives the IP address.
- Note: behind load balancers, this changes. 

2. then we store request metadata using a global dictionary:

```python
rate_limit_score = {}
```

- structure:

```python
{
    "127.0.0.1": {
        "count": 3,
        "window_start": 1700000000.0
    }
}
```

**Logic Flow**

when request arrives:
- get IP
- if IP not in store -> initialize
- if current_time - window_start > WINDOW:
    - reset counter
- increment counter
- if counter > LIMIT -> return 429
